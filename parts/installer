#!/bin/sh -e
# Copyright (c) 2014 The crouton Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

# Functions for installing things

# Installs a script to a destination, expanding any import* or from* calls into
# static insertions. If the file is a symlink, copies the symlink without
# modification.
# $1: the source script to process
# $2: the destination file or directory
# $3: optional additional commands to pass to sed (passed to -e)
installscript() {
    local src="$1" dst="$2"
    if [ -d "$dst" -o ! "${dst%/}" = "$dst" ]; then
        mkdir -p "$dst"
        dst="${dst%/}/${src##*/}"
    fi
    if [ -h "$src" ]; then
        cp -fPT "$src" "$dst"
        return
    fi
    # Process the input in two stages.
    # awk generates commands to shell by prefixing the string with a character
    #   n: print text with newline
    #   e: print text without newline
    #   f: process from command
    #   i: process import command
    awk '
    !x && match($0, "/parts/common$") {
        x = 1
        next
    }
    !x { print }
    x {
        if (match($0, "from [a-z-_/]+ import|print|run ([a-zA-Z_]+[, ])+")) {
            print "e" substr($0, 1, RSTART-1)
            print "f" substr($0, RSTART, RLENGTH)
            print "n" substr($0, RSTART+RLENGTH)
        } else if (match($0, "^ *import ([a-z-_]+[, ])+$")) {
            print "i" $0
        } else {
            print "n" $0
        }
    }' "$src" | (OLDIFS="$IFS"; IFS=''; while read -r line; do
        case "$line" in
            e*) echo -n "${line#e}";;
            n*) echo -n "${line#n}
";;
            i*) IFS=' ,'
                for file in ${line#*import}; do
                    file="$SCRIPTDIR/parts/$file"
                    if [ -f "$file" ]; then
                        cat "$file"
                    fi
                done
                IFS='';;
            f*) echo -n "${line#*from}" | {
                    IFS=' ,'
                    read file cmd func params
                    IFS="$OLDIFS"
                    if [ "$cmd" = 'import' ]; then
                        from "$file" print $func $params
                    elif [ "$cmd" = 'run' ]; then
                        echo -n "("
                        from "$file" print $func
                        echo "$func $params)"
                    else
                        # This should not be hit unless in dead imported code...
                        echo ':'
                    fi
                    IFS=''
                };;
            *) error 3 "installscript is broken :(";;
        esac
    done) | sed -e "${3:-;}" > "$dst"
}

# Compares $RELEASE to the specified releases, assuming $DISTRODIR/releases is
# sorted oldest to newest. Every two parameters are considered criteria that are
# ORed together. The first parameter is the comparator, as provided to "test".
# The second parameter is the release to compare to. A comparison against a
# release from a different distro always fails. Since either $DISTRODIR/releases
# has to be readable or the release list has to be embedded, and RELEASE has to
# be set properly, this function should only be used in the context of targets.
# Returns non-zero if the release doesn't match
# Example:  release -ge quantal -ge wheezy
release() {
    if [ "$(($# % 2))" -ne 0 ]; then
        error 3 "invalid parameters to release(): $*"
    fi
    # Load up the list of releases; this will be replaced with a literal list
    local releases="`cat "$DISTRODIR/releases" 2>/dev/null`"
    if [ -z "$releases" ]; then
        error 3 "list of releases for $DISTRO not found"
    fi
    # End-of-word regex for awk
    local eow='([^a-z]|$)'
    local relnum="`echo "$releases" | awk "/^$RELEASE$eow/ {print NR; exit}"`"
    if [ -z "$relnum" ]; then
        error 3 "$RELEASE not found in $DISTRO"
    fi
    while [ "$#" -ge 2 ]; do
        local cmp="`echo "$releases" | awk "/^$2$eow/ {print NR; exit}"`"
        if [ -n "$cmp" ] && test "$relnum" "$1" "$cmp"; then
            return 0
        fi
        shift 2
    done
    return 1
}

